# VidFab ä»£ç æ”¹é€ è¯¦ç»†æŒ‡å—

æœ¬æ–‡æ¡£æä¾›å…·ä½“çš„ä»£ç æ”¹é€ ç¤ºä¾‹å’Œæœ€ä½³å®è·µã€‚

---

## ğŸ“¦ ä¾èµ–åŒ…å˜æ›´

### éœ€è¦å®‰è£…çš„æ–°åŒ…

```bash
# Inngest (ä»»åŠ¡é˜Ÿåˆ—)
npm install inngest

# Upstash Redis (Serverless Redis)
npm install @upstash/redis

# Cloudinary (è§†é¢‘å¤„ç†)
npm install cloudinary

# Axiom (æ—¥å¿—èšåˆ)
npm install next-axiom

# Vercel CLI (éƒ¨ç½²å·¥å…·)
npm install -g vercel
```

### å¯ä»¥ä¿ç•™çš„åŒ… (å¯é€‰åˆ é™¤)

```bash
# è¿™äº›åŒ…å¯ä»¥æš‚æ—¶ä¿ç•™,ä½œä¸ºå¤‡ä»½
# ç¡®è®¤è¿ç§»æˆåŠŸåå†åˆ é™¤

# npm uninstall ioredis  # æ”¹ç”¨ @upstash/redis
# npm uninstall bullmq   # æ”¹ç”¨ inngest
# npm uninstall node-cron  # æ”¹ç”¨ Vercel Cron
```

---

## ğŸ”„ Redis å®¢æˆ·ç«¯æ”¹é€ 

### åŸä»£ç  (`/lib/redis.ts`)

```typescript
import Redis from 'ioredis'

export const redis = new Redis({
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  password: process.env.REDIS_PASSWORD,
  db: parseInt(process.env.REDIS_DB || '0'),
  retryStrategy: (times) => {
    return Math.min(times * 50, 2000)
  },
  maxRetriesPerRequest: 3,
})

// å¯¼å‡º RedisCache ç±»
export class RedisCache {
  async set(key: string, value: any, expirationSeconds?: number) {
    const serialized = JSON.stringify(value)
    if (expirationSeconds) {
      await redis.setex(key, expirationSeconds, serialized)
    } else {
      await redis.set(key, serialized)
    }
  }

  async get<T>(key: string): Promise<T | null> {
    const data = await redis.get(key)
    return data ? JSON.parse(data) : null
  }

  async delete(key: string) {
    await redis.del(key)
  }
}
```

### æ–°ä»£ç  (Upstash)

```typescript
import { Redis } from '@upstash/redis'

// åˆ›å»º Redis å®¢æˆ·ç«¯
export const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
})

// RedisCache ç±» - API å‡ ä¹å®Œå…¨å…¼å®¹!
export class RedisCache {
  async set(key: string, value: any, expirationSeconds?: number) {
    if (expirationSeconds) {
      await redis.set(key, value, { ex: expirationSeconds })
    } else {
      await redis.set(key, value)
    }
  }

  async get<T>(key: string): Promise<T | null> {
    const data = await redis.get<T>(key)
    return data
  }

  async delete(key: string) {
    await redis.del(key)
  }

  // æ–°å¢: æ‰¹é‡æ“ä½œ (Upstash ä¼˜åŒ–)
  async mget<T>(keys: string[]): Promise<(T | null)[]> {
    return await redis.mget<T>(...keys)
  }

  async mset(data: Record<string, any>, expirationSeconds?: number) {
    const pipeline = redis.pipeline()
    Object.entries(data).forEach(([key, value]) => {
      if (expirationSeconds) {
        pipeline.set(key, value, { ex: expirationSeconds })
      } else {
        pipeline.set(key, value)
      }
    })
    await pipeline.exec()
  }
}

export const cache = new RedisCache()
```

**å…³é”®å˜åŒ–**:
- âœ… `setex(key, seconds, value)` â†’ `set(key, value, { ex: seconds })`
- âœ… è‡ªåŠ¨ JSON åºåˆ—åŒ– (Upstash å†…ç½®)
- âœ… æ”¯æŒ TypeScript æ³›å‹

---

## âš™ï¸ ä»»åŠ¡é˜Ÿåˆ—æ”¹é€ 

### åŸä»£ç  (BullMQ)

```typescript
// /lib/queue/queue-manager.ts
import { Queue, Worker } from 'bullmq'
import { redis } from '../redis'

const queue = new Queue('vidfab-video-processing', {
  connection: redis,
})

// æ·»åŠ ä»»åŠ¡
export async function addDownloadTask(videoId: string, url: string) {
  await queue.add('download_video', { videoId, url }, {
    priority: 2,
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 60000
    }
  })
}

// Worker å¤„ç†
const worker = new Worker(
  'vidfab-video-processing',
  async (job) => {
    if (job.name === 'download_video') {
      await downloadVideo(job.data.videoId, job.data.url)
    }
  },
  { connection: redis, concurrency: 3 }
)
```

### æ–°ä»£ç  (Inngest)

#### 1. åˆ›å»ºå®¢æˆ·ç«¯ (`/lib/inngest/client.ts`)

```typescript
import { Inngest } from 'inngest'

export const inngest = new Inngest({
  id: 'vidfab',
  name: 'VidFab AI Video Platform',
  eventKey: process.env.INNGEST_EVENT_KEY!,
})
```

#### 2. å®šä¹‰ Functions (`/lib/inngest/functions/video-processing.ts`)

```typescript
import { inngest } from '../client'
import { supabase } from '@/lib/supabase'
import { downloadFromWavespeed } from '@/lib/services/wavespeed-api'

// è§†é¢‘ä¸‹è½½ä»»åŠ¡
export const downloadVideo = inngest.createFunction(
  {
    id: 'download-video',
    name: 'Download Video from Wavespeed',
    retries: 3,
    timeout: '10m',  // 10åˆ†é’Ÿè¶…æ—¶
  },
  { event: 'video/download.requested' },
  async ({ event, step }) => {
    const { videoId, url, userId } = event.data

    // Step 1: æ›´æ–°çŠ¶æ€ä¸º downloading
    await step.run('update-status-downloading', async () => {
      await supabase
        .from('user_videos')
        .update({ status: 'downloading' })
        .eq('id', videoId)
    })

    // Step 2: ä» Wavespeed ä¸‹è½½
    const videoBuffer = await step.run('download-from-wavespeed', async () => {
      return await downloadFromWavespeed(url)
    })

    // Step 3: ä¸Šä¼ åˆ° Supabase Storage
    const uploadResult = await step.run('upload-to-supabase', async () => {
      const { data, error } = await supabase.storage
        .from('user-videos')
        .upload(`${userId}/${videoId}.mp4`, videoBuffer, {
          contentType: 'video/mp4'
        })

      if (error) throw error
      return data
    })

    // Step 4: æ›´æ–°æ•°æ®åº“
    await step.run('update-database', async () => {
      await supabase
        .from('user_videos')
        .update({
          status: 'completed',
          file_url: uploadResult.path,
          file_size: videoBuffer.length
        })
        .eq('id', videoId)
    })

    // Step 5: è§¦å‘ç¼©ç•¥å›¾ç”Ÿæˆ
    await step.run('trigger-thumbnail', async () => {
      await inngest.send({
        name: 'video/thumbnail.requested',
        data: { videoId, videoUrl: uploadResult.path }
      })
    })

    // Step 6: å»¶è¿Ÿæ¸…ç†ä»»åŠ¡ (24å°æ—¶å)
    await step.sleep('24h')
    await step.run('schedule-cleanup', async () => {
      await inngest.send({
        name: 'video/cleanup.scheduled',
        data: { videoId }
      })
    })

    return { success: true, videoId }
  }
)

// ç¼©ç•¥å›¾ç”Ÿæˆä»»åŠ¡
export const generateThumbnail = inngest.createFunction(
  {
    id: 'generate-thumbnail',
    name: 'Generate Video Thumbnail',
    retries: 3,
    timeout: '2m',
  },
  { event: 'video/thumbnail.requested' },
  async ({ event, step }) => {
    const { videoId, videoUrl } = event.data

    const thumbnailUrl = await step.run('generate-thumbnail', async () => {
      // ä½¿ç”¨ Cloudinary ç”Ÿæˆç¼©ç•¥å›¾ (è§ä¸‹æ–‡)
      return await generateThumbnailFromVideo(videoUrl)
    })

    await step.run('update-thumbnail-url', async () => {
      await supabase
        .from('user_videos')
        .update({ thumbnail_url: thumbnailUrl })
        .eq('id', videoId)
    })

    return { success: true, thumbnailUrl }
  }
)

// æ¸…ç†ä¸´æ—¶æ–‡ä»¶
export const cleanupTempFiles = inngest.createFunction(
  {
    id: 'cleanup-temp-files',
    name: 'Cleanup Temporary Files',
  },
  { event: 'video/cleanup.scheduled' },
  async ({ event, step }) => {
    const { videoId } = event.data

    await step.run('delete-temp-files', async () => {
      // åˆ é™¤ Wavespeed ä¸´æ—¶æ–‡ä»¶
      // æˆ–æ¸…ç†è¿‡æœŸè§†é¢‘ (å…è´¹ç”¨æˆ· 24h ååˆ é™¤)
      const { data: video } = await supabase
        .from('user_videos')
        .select('user_id, subscription_plan')
        .eq('id', videoId)
        .single()

      if (video?.subscription_plan === 'free') {
        // åˆ é™¤è§†é¢‘æ–‡ä»¶
        await supabase.storage
          .from('user-videos')
          .remove([`${video.user_id}/${videoId}.mp4`])

        // æ›´æ–°æ•°æ®åº“
        await supabase
          .from('user_videos')
          .update({ status: 'expired' })
          .eq('id', videoId)
      }
    })

    return { success: true }
  }
)
```

#### 3. åˆ›å»º API è·¯ç”± (`/app/api/inngest/route.ts`)

```typescript
import { serve } from 'inngest/next'
import { inngest } from '@/lib/inngest/client'
import {
  downloadVideo,
  generateThumbnail,
  cleanupTempFiles,
} from '@/lib/inngest/functions/video-processing'

export const { GET, POST, PUT } = serve({
  client: inngest,
  functions: [
    downloadVideo,
    generateThumbnail,
    cleanupTempFiles,
  ],
  signingKey: process.env.INNGEST_SIGNING_KEY!,
  landingPage: process.env.NODE_ENV === 'development',
})
```

#### 4. è§¦å‘ä»»åŠ¡ (æ”¹é€  API è·¯ç”±)

```typescript
// /app/api/video/generate/route.ts

// âŒ æ—§ä»£ç 
import { videoQueueManager } from '@/lib/queue/queue-manager'
await videoQueueManager.addJob('download_video', { videoId, url })

// âœ… æ–°ä»£ç 
import { inngest } from '@/lib/inngest/client'
await inngest.send({
  name: 'video/download.requested',
  data: { videoId, url, userId }
})
```

**å…³é”®ä¼˜åŠ¿**:
- âœ… `step.run()` è‡ªåŠ¨é‡è¯•å’Œé”™è¯¯è¿½è¸ª
- âœ… `step.sleep()` åŸç”Ÿæ”¯æŒå»¶è¿Ÿä»»åŠ¡
- âœ… å†…ç½®ç›‘æ§é¢æ¿ (Inngest Dashboard)
- âœ… æ”¯æŒé•¿ä»»åŠ¡ (æœ€é«˜ 1 å°æ—¶)

---

## ğŸ¬ è§†é¢‘å¤„ç†æ”¹é€ 

### åŸä»£ç  (ffmpeg)

```typescript
// /lib/services/video-thumbnail.ts
import ffmpeg from 'fluent-ffmpeg'
import fs from 'fs/promises'
import path from 'path'

export async function generateThumbnail(videoPath: string): Promise<Buffer> {
  const outputPath = path.join('/tmp', `thumbnail-${Date.now()}.jpg`)

  // ä½¿ç”¨ ffmpeg ç”Ÿæˆç¼©ç•¥å›¾
  await new Promise((resolve, reject) => {
    ffmpeg(videoPath)
      .screenshots({
        timestamps: ['2'],  // ç¬¬ 2 ç§’
        filename: path.basename(outputPath),
        folder: path.dirname(outputPath),
        size: '640x360'
      })
      .on('end', resolve)
      .on('error', reject)
  })

  // è¯»å–æ–‡ä»¶
  const buffer = await fs.readFile(outputPath)

  // åˆ é™¤ä¸´æ—¶æ–‡ä»¶
  await fs.unlink(outputPath)

  return buffer
}
```

### æ–°ä»£ç  (Cloudinary)

```typescript
// /lib/cloudinary.ts
import { v2 as cloudinary } from 'cloudinary'

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME!,
  api_key: process.env.CLOUDINARY_API_KEY!,
  api_secret: process.env.CLOUDINARY_API_SECRET!,
})

export { cloudinary }

// /lib/services/thumbnail-service.ts
import { cloudinary } from '@/lib/cloudinary'
import { supabase } from '@/lib/supabase'

export class ThumbnailService {
  /**
   * æ–¹æ¡ˆ A: ä» Supabase URL ç›´æ¥ç”Ÿæˆç¼©ç•¥å›¾ (æ¨è)
   * ä¼˜åŠ¿: ä¸éœ€è¦ä¸Šä¼ åˆ° Cloudinary,èŠ‚çœæˆæœ¬
   */
  static async generateFromSupabaseUrl(
    videoUrl: string
  ): Promise<string> {
    // è·å– Supabase å…¬å¼€ URL
    const { data } = supabase.storage
      .from('user-videos')
      .getPublicUrl(videoUrl)

    // ä½¿ç”¨ Cloudinary Fetch ç”Ÿæˆç¼©ç•¥å›¾
    const thumbnailUrl = cloudinary.url(data.publicUrl, {
      resource_type: 'video',
      type: 'fetch',
      format: 'jpg',
      transformation: [
        {
          width: 640,
          height: 360,
          crop: 'fill',
          quality: 'auto',
          fetch_format: 'auto'  // è‡ªåŠ¨ä¼˜åŒ–æ ¼å¼ (WebP)
        },
        { start_offset: '2' }  // ç¬¬ 2 ç§’çš„å¸§
      ]
    })

    return thumbnailUrl
  }

  /**
   * æ–¹æ¡ˆ B: ä¸Šä¼ åˆ° Cloudinary (å¯é€‰)
   * ä¼˜åŠ¿: Cloudinary CDN åŠ é€Ÿ,æ›´å¿«çš„åŠ è½½é€Ÿåº¦
   */
  static async uploadAndGenerate(
    videoBuffer: Buffer,
    userId: string,
    videoId: string
  ): Promise<{ videoUrl: string; thumbnailUrl: string }> {
    // ä¸Šä¼ åˆ° Cloudinary
    const result = await new Promise((resolve, reject) => {
      const uploadStream = cloudinary.uploader.upload_stream(
        {
          resource_type: 'video',
          folder: `vidfab-videos/${userId}`,
          public_id: videoId,
          transformation: [
            { quality: 'auto' }
          ]
        },
        (error, result) => {
          if (error) reject(error)
          else resolve(result)
        }
      )

      uploadStream.end(videoBuffer)
    })

    // ç”Ÿæˆç¼©ç•¥å›¾ URL
    const thumbnailUrl = cloudinary.url(result.public_id, {
      resource_type: 'video',
      format: 'jpg',
      transformation: [
        { width: 640, height: 360, crop: 'fill', quality: 'auto' },
        { start_offset: '2' }
      ]
    })

    return {
      videoUrl: result.secure_url,
      thumbnailUrl
    }
  }
}
```

**æ¨è**: ä½¿ç”¨æ–¹æ¡ˆ A (Fetch),æˆæœ¬ä¸º $0

**å‡çº§è·¯å¾„**: æµé‡å¤§æ—¶åˆ‡æ¢åˆ°æ–¹æ¡ˆ B

---

## ğŸ“ æ—¥å¿—ç³»ç»Ÿæ”¹é€ 

### åŸä»£ç  (console.log)

```typescript
// æ•£è½åœ¨å„å¤„çš„æ—¥å¿—
console.log('Video generated', { videoId })
console.error('Download failed', error)
console.warn('Low credits', { userId, credits })
```

### æ–°ä»£ç  (Axiom)

#### 1. é…ç½® next.config.mjs

```javascript
import { withAxiom } from 'next-axiom'

const nextConfig = {
  // ä½ çš„é…ç½®
}

export default withAxiom(nextConfig)
```

#### 2. åˆ›å»º Logger å·¥å…· (`/lib/logger.ts`)

```typescript
import { log as axiomLog } from 'next-axiom'

export const logger = {
  info: (message: string, data?: Record<string, any>) => {
    console.log(message, data)
    axiomLog.info(message, data || {})
  },

  error: (message: string, error?: Error | unknown, data?: Record<string, any>) => {
    console.error(message, error)
    axiomLog.error(message, {
      ...data,
      error: error instanceof Error ? {
        message: error.message,
        stack: error.stack,
        name: error.name
      } : String(error)
    })
  },

  warn: (message: string, data?: Record<string, any>) => {
    console.warn(message, data)
    axiomLog.warn(message, data || {})
  },

  // è‡ªå®šä¹‰: è§†é¢‘ç”Ÿæˆäº‹ä»¶
  videoGenerated: (data: {
    videoId: string
    userId: string
    duration?: number
    type: 'text-to-video' | 'image-to-video'
  }) => {
    logger.info('Video generated', {
      event: 'video.generated',
      ...data
    })
  },

  // è‡ªå®šä¹‰: æ”¯ä»˜äº‹ä»¶
  paymentSuccess: (data: {
    userId: string
    amount: number
    plan: string
    orderId: string
  }) => {
    logger.info('Payment successful', {
      event: 'payment.success',
      ...data
    })
  },
}
```

#### 3. ä½¿ç”¨ç¤ºä¾‹

```typescript
// /app/api/video/generate/route.ts
import { logger } from '@/lib/logger'

export async function POST(request: Request) {
  try {
    const { prompt, userId } = await request.json()

    logger.info('Video generation started', {
      userId,
      prompt: prompt.substring(0, 50)
    })

    // ç”Ÿæˆè§†é¢‘
    const video = await generateVideo(prompt)

    logger.videoGenerated({
      videoId: video.id,
      userId,
      type: 'text-to-video'
    })

    return Response.json({ success: true, video })
  } catch (error) {
    logger.error('Video generation failed', error, {
      userId,
      prompt
    })
    return Response.json(
      { error: 'Failed to generate video' },
      { status: 500 }
    )
  }
}
```

---

## ğŸ”— ç›¸å…³æ–‡æ¡£

- [04-åˆ†é˜¶æ®µæ‰§è¡Œè®¡åˆ’.md](./04-åˆ†é˜¶æ®µæ‰§è¡Œè®¡åˆ’.md) - æ‰§è¡Œæ­¥éª¤
- [06-è¿ç§»æ£€æŸ¥æ¸…å•.md](./06-è¿ç§»æ£€æŸ¥æ¸…å•.md) - æ£€æŸ¥æ¸…å•
