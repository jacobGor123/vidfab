/**
 * NextAuth Configuration for VidFab AI Video Platform
 */
import CredentialsProvider from "next-auth/providers/credentials";
import GoogleProvider from "next-auth/providers/google";
import { NextAuthConfig } from "next-auth";
import { Provider } from "next-auth/providers/index";
import { User } from "@/types/user";
import { getClientIp } from "@/lib/ip";
import { getIsoTimestr } from "@/lib/time";
import { getUuid, getUserUuidFromEmail } from "@/lib/hash";

let providers: Provider[] = [];

// Verification Code Login Provider
providers.push(
  CredentialsProvider({
    id: "verification-code",
    name: "verification-code",
    credentials: {
      email: { type: "email" },
      token: { type: "text" }
    },
    async authorize(credentials) {
      if (!credentials?.email || !credentials?.token) return null;

      const email = credentials.email as string;
      const token = credentials.token as string;

      // Validate the verification token (generated by verification API)
      if (token.startsWith('verified-')) {
        // Trust that the verification API has already validated the code
        // Generate deterministic UUID based on email for consistent user identity
        return {
          id: getUserUuidFromEmail(email), // Use deterministic UUID based on email
          email: email,
          name: email.split('@')[0],
        };
      }

      return null;
    },
  })
);

// Google One Tap Authentication
if (
  process.env.NEXT_PUBLIC_AUTH_GOOGLE_ONE_TAP_ENABLED === "true" &&
  process.env.NEXT_PUBLIC_AUTH_GOOGLE_ID
) {
  providers.push(
    CredentialsProvider({
      id: "google-one-tap",
      name: "google-one-tap",

      credentials: {
        credential: { type: "text" },
      },

      async authorize(credentials, req) {
        const googleClientId = process.env.NEXT_PUBLIC_AUTH_GOOGLE_ID;
        if (!googleClientId) {
          console.error("Invalid Google auth config");
          return null;
        }

        const token = credentials!.credential;

        try {
          const response = await fetch(
            "https://oauth2.googleapis.com/tokeninfo?id_token=" + token
          );
          
          if (!response.ok) {
            console.error("Failed to verify token");
            return null;
          }

          const payload = await response.json();
          if (!payload) {
            console.error("Invalid payload from token");
            return null;
          }

          const {
            email,
            sub,
            given_name,
            family_name,
            email_verified,
            picture: image,
          } = payload;
          
          if (!email) {
            console.error("Invalid email in payload");
            return null;
          }

          const user = {
            id: sub,
            name: [given_name, family_name].join(" ").trim(),
            email,
            image,
            emailVerified: email_verified ? new Date() : null,
          };

          return user;
        } catch (error) {
          console.error("Google One Tap auth error:", error);
          return null;
        }
      },
    })
  );
}

// Standard Google OAuth
if (
  process.env.NEXT_PUBLIC_AUTH_GOOGLE_ENABLED === "true" &&
  process.env.AUTH_GOOGLE_ID &&
  process.env.AUTH_GOOGLE_SECRET
) {
  providers.push(
    GoogleProvider({
      clientId: process.env.AUTH_GOOGLE_ID,
      clientSecret: process.env.AUTH_GOOGLE_SECRET,
    })
  );
}

export const providerMap = providers
  .map((provider) => {
    if (typeof provider === "function") {
      const providerData = provider();
      return { id: providerData.id, name: providerData.name };
    } else {
      return { id: provider.id, name: provider.name };
    }
  })
  .filter((provider) => provider.id !== "google-one-tap"); // Hide One Tap from UI

export const authConfig: NextAuthConfig = {
  providers,
  basePath: "/api/auth",
  pages: {
    signIn: "/login", // Updated to match our route structure
  },
  session: {
    strategy: "jwt",
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
  trustHost: true, // Required for Docker and production environments
  debug: process.env.NODE_ENV === 'development',
  // Cookie security configuration
  // Allow NEXTAUTH_COOKIE_SECURE env var to override for production environments with proxies
  useSecureCookies: process.env.NEXTAUTH_COOKIE_SECURE === 'false'
    ? false
    : (process.env.NODE_ENV === 'production' && !process.env.DOCKER_ENVIRONMENT),
  cookies: {
    sessionToken: {
      name: `next-auth.session-token`,
      options: {
        httpOnly: true,
        sameSite: "lax",
        path: "/",
        // Allow NEXTAUTH_COOKIE_SECURE env var to override for production environments with proxies
        secure: process.env.NEXTAUTH_COOKIE_SECURE === 'false'
          ? false
          : (process.env.NODE_ENV === 'production' && !process.env.DOCKER_ENVIRONMENT),
        domain: process.env.DOCKER_ENVIRONMENT ? undefined : undefined
      },
    },
  },
  callbacks: {
    async signIn({ user, account, profile }) {
      try {
        console.log('ğŸ” SignIn callback triggered:', {
          provider: account?.provider,
          type: account?.type,
          email: user?.email,
          dockerEnv: !!process.env.DOCKER_ENVIRONMENT
        });

        // Additional validation for Google providers
        if (account?.provider === 'google' || account?.provider === 'google-one-tap') {
          if (!user?.email) {
            console.error('âŒ Google sign-in missing email');
            return false;
          }
          console.log('âœ… Google sign-in validated');
        }

        return true;
      } catch (error) {
        console.error("âŒ SignIn callback error:", error);
        return false;
      }
    },
    
    async redirect({ url, baseUrl }) {
      // Handle redirects after authentication
      try {
        // In Docker environment, handle localhost URLs
        if (process.env.DOCKER_ENVIRONMENT && url.includes('localhost')) {
          // Replace container internal URLs with accessible URLs
          url = url.replace('http://localhost:', `http://localhost:`);
        }

        // Allow relative callback URLs
        if (url.startsWith("/")) {
          return `${baseUrl}${url}`;
        }

        // Allow callback URLs on the same origin
        const urlObj = new URL(url);
        const baseUrlObj = new URL(baseUrl);
        if (urlObj.origin === baseUrlObj.origin) {
          return url;
        }

        // Special handling for Docker environment
        if (process.env.DOCKER_ENVIRONMENT) {
          const dockerBaseUrl = process.env.NEXTAUTH_URL || baseUrl;
          if (url.startsWith("/")) {
            return `${dockerBaseUrl}${url}`;
          }
        }
      } catch (error) {
        console.error('âŒ Invalid URL in redirect:', { url, baseUrl, error });
      }

      return `${baseUrl}/create`; // Default redirect to create page
    },
    
    async session({ session, token }) {
      // Add custom user data to session
      if (token && token.user) {
        session.user = {
          ...session.user,
          ...token.user
        };
      }
      return session;
    },
    
    async jwt({ token, user, account }) {
      try {
        // Handle user creation/update on first sign in
        if (user && user.email && account) {
          // Import saveUser service
          const { saveUser, updateLastLogin } = await import("@/services/user");

          const userData = {
            email: user.email,
            nickname: user.name || user.email.split('@')[0],
            avatar_url: user.image || "",
            signin_type: account.type as 'oauth' | 'credentials',
            signin_provider: account.provider === "google-one-tap" ? "google" : account.provider,
            signin_openid: account.providerAccountId,
            email_verified: true, // OAuth users are automatically verified
            signin_ip: await getClientIp(),
          };

          try {
            const savedUser = await saveUser(userData);

            // Update last login
            await updateLastLogin(savedUser.uuid, await getClientIp());

            token.user = {
              uuid: savedUser.uuid,
              email: savedUser.email,
              nickname: savedUser.nickname,
              avatar_url: savedUser.avatar_url,
              created_at: savedUser.created_at,
            };
          } catch (saveError) {
            console.error("Failed to save user:", saveError);
            // Fallback to basic token data with deterministic UUID
            token.user = {
              uuid: getUserUuidFromEmail(user.email), // Use deterministic UUID based on email
              email: user.email,
              nickname: user.name || user.email.split('@')[0],
              avatar_url: user.image || "",
              created_at: getIsoTimestr(),
            };
          }
        }

        // ğŸ”¥ ç¡®ä¿æ¯æ¬¡ç™»å½•éƒ½éªŒè¯ç”¨æˆ·åœ¨æ•°æ®åº“ä¸­çš„å­˜åœ¨æ€§
        if (token.user && token.user.uuid && token.user.email) {
          try {
            const { getUserByUuid, getUserByEmail, saveUser } = await import("@/services/user");
            let existingUser = await getUserByUuid(token.user.uuid);

            // ğŸ”¥ å¦‚æœUUIDä¸åŒ¹é…ï¼Œå…ˆæ£€æŸ¥æ˜¯å¦æœ‰ä½¿ç”¨è¯¥é‚®ç®±çš„ç”¨æˆ·è®°å½•
            if (!existingUser) {
              console.log(`ğŸ”§ UUID ${token.user.uuid} ä¸å­˜åœ¨ï¼Œæ£€æŸ¥é‚®ç®± ${token.user.email}`);

              const userByEmail = await getUserByEmail(token.user.email);
              if (userByEmail) {
                console.log(`âœ… æ‰¾åˆ°é‚®ç®±å¯¹åº”çš„ç”¨æˆ·ï¼Œä½¿ç”¨æ•°æ®åº“UUID: ${userByEmail.uuid}`);
                // æ›´æ–°tokenä½¿ç”¨æ•°æ®åº“ä¸­çš„å®é™…UUID
                token.user = {
                  ...token.user,
                  uuid: userByEmail.uuid,
                  nickname: userByEmail.nickname || token.user.nickname,
                  avatar_url: userByEmail.avatar_url || token.user.avatar_url,
                  created_at: userByEmail.created_at
                };
                existingUser = userByEmail;
              } else {
                console.log(`ğŸ”§ é‚®ç®± ${token.user.email} ä¹Ÿä¸å­˜åœ¨ï¼Œé‡æ–°åˆ›å»ºç”¨æˆ·`);
                // ç”¨æˆ·å®Œå…¨ä¸å­˜åœ¨ï¼Œé‡æ–°åˆ›å»º
                const userData = {
                  email: token.user.email,
                  nickname: token.user.nickname || token.user.email.split('@')[0],
                  avatar_url: token.user.avatar_url || "",
                  signin_type: 'credentials' as const,
                  signin_provider: 'verification-code',
                  signin_openid: token.user.uuid,
                  email_verified: true,
                  signin_ip: await getClientIp(),
                };

                const newUser = await saveUser(userData);
                token.user.uuid = newUser.uuid; // ä½¿ç”¨æ•°æ®åº“ç”Ÿæˆçš„UUID
                console.log(`âœ… ç”¨æˆ·é‡æ–°åˆ›å»ºæˆåŠŸ: ${newUser.uuid}`);
              }
            }
          } catch (error) {
            console.error("JWTç”¨æˆ·éªŒè¯å¤±è´¥:", error);
          }
        }

        return token;
      } catch (error) {
        console.error("JWT callback error:", error);
        return token;
      }
    },
  },
  events: {
    async signIn({ user, account, profile, isNewUser }) {
    },
    async signOut({ token, session }) {
    },
  },
  secret: process.env.NEXTAUTH_SECRET,
};

// Legacy export for compatibility
export const authOptions = authConfig;