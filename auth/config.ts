/**
 * NextAuth Configuration for VidFab AI Video Platform
 */
import CredentialsProvider from "next-auth/providers/credentials";
import GoogleProvider from "next-auth/providers/google";
import { NextAuthConfig } from "next-auth";
import { Provider } from "next-auth/providers/index";
import { User } from "@/types/user";
import { getClientIp } from "@/lib/ip";
import { getIsoTimestr } from "@/lib/time";
import { getUuid } from "@/lib/hash";

let providers: Provider[] = [];

// Verification Code Login Provider
providers.push(
  CredentialsProvider({
    id: "verification-code",
    name: "verification-code",
    credentials: {
      email: { type: "email" },
      token: { type: "text" }
    },
    async authorize(credentials) {
      if (!credentials?.email || !credentials?.token) return null;

      const email = credentials.email as string;
      const token = credentials.token as string;

      // Validate the verification token (generated by verification API)
      if (token.startsWith('verified-')) {
        // Trust that the verification API has already validated the code
        // Generate a UUID for the user (will be properly set in JWT callback)
        return {
          id: getUuid(), // Generate proper UUID instead of using email
          email: email,
          name: email.split('@')[0],
        };
      }

      return null;
    },
  })
);

// Google One Tap Authentication
if (
  process.env.NEXT_PUBLIC_AUTH_GOOGLE_ONE_TAP_ENABLED === "true" &&
  process.env.NEXT_PUBLIC_AUTH_GOOGLE_ID
) {
  providers.push(
    CredentialsProvider({
      id: "google-one-tap",
      name: "google-one-tap",

      credentials: {
        credential: { type: "text" },
      },

      async authorize(credentials, req) {
        const googleClientId = process.env.NEXT_PUBLIC_AUTH_GOOGLE_ID;
        if (!googleClientId) {
          console.log("Invalid Google auth config");
          return null;
        }

        const token = credentials!.credential;

        try {
          const response = await fetch(
            "https://oauth2.googleapis.com/tokeninfo?id_token=" + token
          );
          
          if (!response.ok) {
            console.log("Failed to verify token");
            return null;
          }

          const payload = await response.json();
          if (!payload) {
            console.log("Invalid payload from token");
            return null;
          }

          const {
            email,
            sub,
            given_name,
            family_name,
            email_verified,
            picture: image,
          } = payload;
          
          if (!email) {
            console.log("Invalid email in payload");
            return null;
          }

          const user = {
            id: sub,
            name: [given_name, family_name].join(" ").trim(),
            email,
            image,
            emailVerified: email_verified ? new Date() : null,
          };

          return user;
        } catch (error) {
          console.error("Google One Tap auth error:", error);
          return null;
        }
      },
    })
  );
}

// Standard Google OAuth
if (
  process.env.NEXT_PUBLIC_AUTH_GOOGLE_ENABLED === "true" &&
  process.env.AUTH_GOOGLE_ID &&
  process.env.AUTH_GOOGLE_SECRET
) {
  providers.push(
    GoogleProvider({
      clientId: process.env.AUTH_GOOGLE_ID,
      clientSecret: process.env.AUTH_GOOGLE_SECRET,
    })
  );
}

export const providerMap = providers
  .map((provider) => {
    if (typeof provider === "function") {
      const providerData = provider();
      return { id: providerData.id, name: providerData.name };
    } else {
      return { id: provider.id, name: provider.name };
    }
  })
  .filter((provider) => provider.id !== "google-one-tap"); // Hide One Tap from UI

export const authConfig: NextAuthConfig = {
  providers,
  basePath: "/api/auth",
  pages: {
    signIn: "/login", // Updated to match our route structure
  },
  session: {
    strategy: "jwt",
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
  trustHost: true, // Required for NextAuth v5
  debug: process.env.NODE_ENV === 'development',
  callbacks: {
    async signIn({ user, account, profile }) {
      try {
        // Allow all sign-ins for now - user creation handled in jwt callback
        return true;
      } catch (error) {
        console.error("SignIn callback error:", error);
        return false;
      }
    },
    
    async redirect({ url, baseUrl }) {
      // Handle redirects after authentication
      try {
        // Allow relative callback URLs
        if (url.startsWith("/")) {
          return `${baseUrl}${url}`;
        }
        
        // Allow callback URLs on the same origin
        const urlObj = new URL(url);
        const baseUrlObj = new URL(baseUrl);
        if (urlObj.origin === baseUrlObj.origin) {
          return url;
        }
      } catch (error) {
        console.error('‚ùå Invalid URL in redirect:', { url, baseUrl, error });
      }
      
      return baseUrl; // Default redirect to home
    },
    
    async session({ session, token }) {
      // Add custom user data to session
      if (token && token.user) {
        session.user = {
          ...session.user,
          ...token.user
        };
      }
      return session;
    },
    
    async jwt({ token, user, account }) {
      try {
        // Handle user creation/update on first sign in
        if (user && user.email && account) {
          // Import saveUser service
          const { saveUser, updateLastLogin } = await import("@/services/user");
          
          const userData = {
            email: user.email,
            nickname: user.name || user.email.split('@')[0],
            avatar_url: user.image || "",
            signin_type: account.type as 'oauth' | 'credentials',
            signin_provider: account.provider === "google-one-tap" ? "google" : account.provider,
            signin_openid: account.providerAccountId,
            email_verified: true, // OAuth users are automatically verified
            signin_ip: await getClientIp(),
          };

          try {
            const savedUser = await saveUser(userData);
            
            // Update last login
            await updateLastLogin(savedUser.uuid, await getClientIp());
            
            token.user = {
              uuid: savedUser.uuid,
              email: savedUser.email,
              nickname: savedUser.nickname,
              avatar_url: savedUser.avatar_url,
              created_at: savedUser.created_at,
            };
          } catch (saveError) {
            console.error("Failed to save user:", saveError);
            // Fallback to basic token data with proper UUID generation
            token.user = {
              uuid: getUuid(), // Always generate a new UUID if save fails
              email: user.email,
              nickname: user.name || user.email.split('@')[0],
              avatar_url: user.image || "",
              created_at: getIsoTimestr(),
            };
          }
        }
        
        return token;
      } catch (error) {
        console.error("JWT callback error:", error);
        return token;
      }
    },
  },
  events: {
    async signIn({ user, account, profile, isNewUser }) {
      console.log(`‚úÖ User signed in: ${user.email} via ${account?.provider}`);
    },
    async signOut({ token, session }) {
      console.log(`üëã User signed out: ${token?.email || session?.user?.email}`);
    },
  },
  secret: process.env.NEXTAUTH_SECRET,
};

// Legacy export for compatibility
export const authOptions = authConfig;